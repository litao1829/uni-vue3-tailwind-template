'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils = require('./utils-17c91589.js');
var webpackSources = require('webpack-sources');
var constants = require('./constants-ff495628.js');

const acceptPrefix = 'abcdefghijklmnopqrstuvwxyz_'.split('');
const acceptChars = 'abcdefghijklmnopqrstuvwxyz_-0123456789'.split('');
function stripEscapeSequence(words) {
    return words.replace(/\\/g, '');
}
const validate = (opts, classGenerator) => {
    if (!opts.log)
        return;
    for (const className in classGenerator.newClassMap) {
        const c = classGenerator.newClassMap[className];
        if (c.usedBy.length >= 1) {
            continue;
        }
        if (c.usedBy[0].match(/.+\.css:*$/)) {
            console.log(`The class name '${className}' is not used: defined at ${c.usedBy[0]}.`);
        }
        else {
            console.log(`The class name '${className}' is not defined: used at ${c.usedBy[0]}.`);
        }
    }
};

class ClassGenerator {
    constructor(opts = {}) {
        this.newClassMap = {};
        this.newClassSize = 0;
        this.context = {};
        this.opts = opts;
    }
    defaultClassGenerator() {
        const chars = [];
        let rest = (this.newClassSize - (this.newClassSize % acceptPrefix.length)) / acceptPrefix.length;
        if (rest > 0) {
            while (true) {
                rest -= 1;
                const m = rest % acceptChars.length;
                const c = acceptChars[m];
                chars.push(c);
                rest -= m;
                if (rest === 0) {
                    break;
                }
                rest /= acceptChars.length;
            }
        }
        const prefixIndex = this.newClassSize % acceptPrefix.length;
        const newClassName = `${acceptPrefix[prefixIndex]}${chars.join('')}`;
        return newClassName;
    }
    ignoreClassName(className) {
        return utils.regExpTest(this.opts.ignoreClass, className);
    }
    includeFilePath(filePath) {
        const { include } = this.opts;
        if (Array.isArray(include)) {
            return utils.regExpTest(include, filePath);
        }
        else {
            return true;
        }
    }
    excludeFilePath(filePath) {
        const { exclude } = this.opts;
        if (Array.isArray(exclude)) {
            return utils.regExpTest(exclude, filePath);
        }
        else {
            return false;
        }
    }
    isFileIncluded(filePath) {
        return this.includeFilePath(filePath) && !this.excludeFilePath(filePath);
    }
    transformCssClass(className) {
        const key = stripEscapeSequence(className);
        const cn = this.newClassMap[key];
        if (cn)
            return cn.name;
        return className;
    }
    generateClassName(original) {
        const opts = this.opts;
        original = stripEscapeSequence(original);
        const cn = this.newClassMap[original];
        if (cn)
            return cn;
        let newClassName;
        if (opts.classGenerator) {
            newClassName = opts.classGenerator(original, opts, this.context);
        }
        if (!newClassName) {
            newClassName = this.defaultClassGenerator();
        }
        if (opts.reserveClassName && utils.regExpTest(opts.reserveClassName, newClassName)) {
            if (opts.log) {
                console.log(`The class name has been reserved. ${newClassName}`);
            }
            this.newClassSize++;
            return this.generateClassName(original);
        }
        if (opts.log) {
            console.log(`Minify class name from ${original} to ${newClassName}`);
        }
        const newClass = {
            name: newClassName,
            usedBy: []
        };
        this.newClassMap[original] = newClass;
        this.newClassSize++;
        return newClass;
    }
}

const optimize$1 = (chunk, compilation, opts, classGenerator) => chunk.files.forEach((file) => {
    let classnameRegex;
    if (file.match(/.+\.css.*$/)) {
        classnameRegex = new RegExp(`\\\.(${opts.classNameRegExp})`, 'g');
    }
    else if (file.match(/.+\.js.*$/) || file.match(/.+\.html.*$/)) {
        classnameRegex = new RegExp(`["'.\\\s](${opts.classNameRegExp})`, 'g');
    }
    if (!classnameRegex) {
        return;
    }
    if (opts.ignorePrefix && opts.ignorePrefixRegExp) {
        throw new Error('Use only either "ignorePrefix" or "ignorePrefixRegExp".');
    }
    let ignorePrefixRegExp;
    let match;
    let newClass;
    if (opts.ignorePrefixRegExp) {
        ignorePrefixRegExp = new RegExp(`^${opts.ignorePrefixRegExp}`);
    }
    const originalSource = compilation.assets[file];
    const rawSource = originalSource.source();
    let source;
    while ((match = classnameRegex.exec(rawSource))) {
        const originalName = match[1];
        let targetName = originalName;
        let originalPrefix = '';
        if (opts.ignorePrefix) {
            let ignorePrefix = opts.ignorePrefix;
            if (typeof ignorePrefix === 'string') {
                ignorePrefix = [ignorePrefix];
            }
            for (let i = 0; i < ignorePrefix.length; i++) {
                if (originalName.startsWith(ignorePrefix[i])) {
                    originalPrefix = ignorePrefix[i];
                    break;
                }
            }
        }
        if (ignorePrefixRegExp) {
            const prefix = ignorePrefixRegExp.exec(originalName);
            if (prefix && prefix.length > 0) {
                originalPrefix = prefix[0];
            }
        }
        if (originalPrefix) {
            targetName = originalName.slice(originalPrefix.length);
            if (opts.log) {
                console.log(`Skip the prefix ${originalPrefix} of ${originalName}`);
            }
        }
        newClass = classGenerator.generateClassName(targetName);
        if (!source)
            source = new webpackSources.ReplaceSource(originalSource);
        const startPos = match.index + match[0].indexOf(match[1]);
        newClass.usedBy.push(`${file}:${startPos}`);
        const newClassName = `${originalPrefix}${newClass.name}`;
        source.replace(startPos, startPos + originalName.length - 1, newClassName);
    }
    if (!source) {
        return;
    }
    compilation.assets[file] = source;
});
const optimizer$1 = (compiler, compilation, opts) => (chunks) => {
    if (!opts.classNameRegExp)
        throw new Error("'classNameRegExp' option is required. e.g. '[c]-[a-z][a-zA-Z0-9_]*'");
    const classGenerator = new ClassGenerator(opts);
    chunks.forEach((chunk) => optimize$1(chunk, compilation, opts, classGenerator));
    validate(opts, classGenerator);
};

class ManglePluginV4 {
    constructor(opts = {}) {
        this.opts = opts;
    }
    apply(compiler) {
        compiler.hooks.compilation.tap(constants.ManglePluginHooks, (compilation) => {
            const optimize = optimizer$1(compiler, compilation, this.opts);
            compilation.hooks.optimizeChunkAssets.tap(constants.WeappTailwindcssWebpackPluginOptimizeChunkAssetsHooks, (chunks) => {
                optimize(chunks);
            });
        });
    }
}

const optimize = (compiler, [file, originalSource], compilation, opts, classGenerator) => {
    let classnameRegex;
    if (file.match(/.+\.css.*$/)) {
        classnameRegex = new RegExp(`\\\.(${opts.classNameRegExp})`, 'g');
    }
    else if (file.match(/.+\.js.*$/) || file.match(/.+\.html.*$/)) {
        classnameRegex = new RegExp(`["'\`.\\\s](${opts.classNameRegExp})`, 'g');
    }
    if (!classnameRegex) {
        return;
    }
    if (opts.ignorePrefix && opts.ignorePrefixRegExp) {
        throw new Error('Use only either "ignorePrefix" or "ignorePrefixRegExp".');
    }
    let ignorePrefixRegExp;
    let source;
    let match;
    if (opts.ignorePrefixRegExp) {
        ignorePrefixRegExp = new RegExp(`^${opts.ignorePrefixRegExp}`);
    }
    const rawSource = originalSource.source().toString();
    const { ReplaceSource } = compiler.webpack.sources;
    while ((match = classnameRegex.exec(rawSource))) {
        const originalName = match[1];
        let targetName = originalName;
        let originalPrefix = '';
        if (opts.ignorePrefix) {
            let ignorePrefix = opts.ignorePrefix;
            if (typeof ignorePrefix === 'string') {
                ignorePrefix = [ignorePrefix];
            }
            for (let i = 0; i < ignorePrefix.length; i++) {
                if (originalName.startsWith(ignorePrefix[i])) {
                    originalPrefix = ignorePrefix[i];
                    break;
                }
            }
        }
        if (ignorePrefixRegExp) {
            const prefix = ignorePrefixRegExp.exec(originalName);
            if (prefix && prefix.length > 0) {
                originalPrefix = prefix[0];
            }
        }
        if (originalPrefix) {
            targetName = originalName.slice(originalPrefix.length);
            if (opts.log) {
                console.log(`Skip the prefix ${originalPrefix} of ${originalName}`);
            }
        }
        const newClass = classGenerator.generateClassName(targetName);
        if (!source)
            source = new ReplaceSource(originalSource);
        const startPos = match.index + match[0].indexOf(match[1]);
        newClass.usedBy.push(`${file}:${startPos}`);
        const newClassName = `${originalPrefix}${newClass.name}`;
        source.replace(startPos, startPos + originalName.length - 1, newClassName);
    }
    if (!source) {
        return;
    }
    compilation.updateAsset(file, source);
};
const optimizer = (compiler, compilation, opts) => (assets) => {
    if (!opts.classNameRegExp)
        throw new Error("'classNameRegExp' option is required. e.g. '[c]-[a-z][a-zA-Z0-9_]*'");
    const classGenerator = new ClassGenerator(opts);
    Object.entries(assets).forEach((asset) => optimize(compiler, asset, compilation, opts, classGenerator));
    validate(opts, classGenerator);
};

class ManglePluginV5 {
    constructor(opts = {}) {
        this.opts = opts;
    }
    apply(compiler) {
        compiler.hooks.compilation.tap(constants.ManglePluginHooks, (compilation) => {
            const optimize = optimizer(compiler, compilation, this.opts);
            compilation.hooks.processAssets.tap(constants.WeappTailwindcssWebpackPluginOptimizeChunkAssetsHooks, (chunks) => {
                optimize(chunks);
            });
        });
    }
}

exports.ClassGenerator = ClassGenerator;
exports.ManglePluginV4 = ManglePluginV4;
exports.ManglePluginV5 = ManglePluginV5;
