'use strict';

var utils = require('./utils-17c91589.js');
var micromatch = require('micromatch');
var generate = require('@babel/generator');
var parser = require('@babel/parser');
var traverse = require('@babel/traverse');
var postcss = require('postcss');
var selectorParser = require('postcss-selector-parser');
var path = require('path');
var fs = require('fs');
var semver = require('semver');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var generate__default = /*#__PURE__*/_interopDefaultCompat(generate);
var traverse__default = /*#__PURE__*/_interopDefaultCompat(traverse);
var postcss__default = /*#__PURE__*/_interopDefaultCompat(postcss);
var selectorParser__default = /*#__PURE__*/_interopDefaultCompat(selectorParser);
var path__default = /*#__PURE__*/_interopDefaultCompat(path);
var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);

function isObject(value) {
  return value !== null && typeof value === "object";
}
function _defu(baseObject, defaults, namespace = ".", merger) {
  if (!isObject(defaults)) {
    return _defu(baseObject, {}, namespace, merger);
  }
  const object = Object.assign({}, defaults);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === void 0) {
      continue;
    }
    if (merger && merger(object, key, value, namespace)) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (isObject(value) && isObject(object[key])) {
      object[key] = _defu(value, object[key], (namespace ? `${namespace}.` : "") + key.toString(), merger);
    } else {
      object[key] = value;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => arguments_.reduce((p, c) => _defu(p, c, "", merger), {});
}
const defu = createDefu();

function mangleMark(str, oldValue, classGenerator) {
    if (typeof str === 'string' && str) {
        const oldStrArr = oldValue.split(' ').filter((x) => x);
        return str
            .split(' ')
            .filter((x) => x)
            .map((x, idx) => {
            if (classGenerator.ignoreClassName(x) || classGenerator.ignoreClassName(oldStrArr[idx])) {
                return x;
            }
            return classGenerator.generateClassName(x).name;
        })
            .join(' ');
    }
    return str;
}

const MappingChars2String = {
    '[': '_bl_',
    ']': '_br_',
    '(': '_pl_',
    ')': '_qr_',
    '#': '_h_',
    '!': '_i_',
    '/': '_s_',
    '\\': '_bs_',
    '.': '_d_',
    ':': '_c_',
    '%': '_p_',
    ',': '_co_',
    "'": '_q_',
    '"': '_dq_',
    '*': '_a_',
    '&': '_am_',
    '@': '_at_',
    '{': '_bal_',
    '}': '_bar_',
    '+': '_plus_',
    ';': '_se_',
    '<': '_l_',
    '~': '_t_',
    '=': '_e_',
    '>': '_g_',
    '?': '_qu_',
    '^': '_ca_',
    '`': '_bq_',
    '|': '_b_',
    $: '_do_'
};
const MappingChars2StringEntries = Object.entries(MappingChars2String);
const SimpleMappingChars2String = {
    '[': '_',
    ']': '_',
    '(': '_',
    ')': '_',
    '{': '_',
    '}': '_',
    '+': 'a',
    ',': 'b',
    ':': 'c',
    '.': 'd',
    '=': 'e',
    ';': 'f',
    '>': 'g',
    '#': 'h',
    '!': 'i',
    '@': 'j',
    '^': 'k',
    '<': 'l',
    '*': 'm',
    '&': 'n',
    '?': 'o',
    '%': 'p',
    "'": 'q',
    $: 'r',
    '/': 's',
    '~': 't',
    '|': 'u',
    '`': 'v',
    '\\': 'w',
    '"': 'x'
};

function escapeStringRegexp(str) {
    if (typeof str !== 'string') {
        throw new TypeError('Expected a string');
    }
    return str.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
}
const templateClassExactRegexp = /(?:(?<=^|\s)(?:hover-)?class)=(?:["']\W+\s*(?:\w+)\()?["']([^"]+)['"]/gs;
const tagWithEitherClassAndHoverClassRegexp = /<(?:[a-z][-a-z]*[a-z]*)\s+[^>]*?(?:(?:hover-)?class="(?:[^"]*)")[^>]*?\/?>/g;
function handleRegexp(reg) {
    return `(?:${reg.source})`;
}
function getSourceString(input) {
    let result;
    if (typeof input === 'string') {
        result = input;
    }
    else if (utils.isRegexp(input)) {
        result = input.source;
    }
    else {
        result = input.toString();
    }
    return result;
}
function makePattern(arr) {
    let pattern = '';
    if (Array.isArray(arr)) {
        pattern = arr
            .reduce((acc, cur) => {
            if (typeof cur === 'string') {
                acc.push(cur);
            }
            else if (utils.isRegexp(cur)) {
                acc.push(handleRegexp(cur));
            }
            return acc;
        }, [])
            .join('|');
    }
    else if (typeof arr === 'string') {
        pattern = arr;
    }
    else if (utils.isRegexp(arr)) {
        pattern = handleRegexp(arr);
    }
    return pattern;
}
function createTempleteHandlerMatchRegexp(tag, attrs, options = {}) {
    const { exact = true } = options;
    const prefix = exact ? '(?<=^|\\s)' : '';
    const pattern = makePattern(attrs);
    let tagPattern = getSourceString(tag);
    if (tagPattern === '*') {
        tagPattern = '[a-z][-a-z]*[a-z]*';
    }
    const source = `<(${tagPattern})\\s+[^>]*?(?:${prefix}(${pattern})="(?:[^"]*)")[^>]*?\\/?>`;
    return new RegExp(source, 'g');
}
function createTemplateClassRegexp(attrs, options = {}) {
    const { exact = true } = options;
    const prefix = exact ? '(?<=^|\\s)' : '';
    const pattern = makePattern(attrs);
    const source = `(?:${prefix}${pattern})=(?:["']\\W+\\s*(?:\\w+)\\()?["']([^"]+)['"]`;
    return new RegExp(source, 'gs');
}
function makeCustomAttributes(entries) {
    if (Array.isArray(entries)) {
        return entries.map(([k, v]) => {
            return {
                tagRegexp: createTempleteHandlerMatchRegexp(k, v),
                attrRegexp: createTemplateClassRegexp(v),
                tag: getSourceString(k),
                attrs: v
            };
        });
    }
}
const variableRegExp = /{{(.*?)}}/gs;
function variableMatch(original) {
    return variableRegExp.exec(original);
}

function escape(selectors, raw = false, entries = MappingChars2StringEntries) {
    let res = selectors;
    for (let i = 0; i < entries.length; i++) {
        const [searchValue, replaceValue] = entries[i];
        res = res.replace(new RegExp((raw ? '\\\\' : '') + escapeStringRegexp(searchValue), 'g'), replaceValue);
    }
    return res;
}

function replaceWxml(original, options = {
    keepEOL: false,
    escapeEntries: MappingChars2StringEntries
}) {
    if (typeof options === 'boolean') {
        options = {
            keepEOL: options
        };
    }
    let res = original;
    if (!options.keepEOL) {
        res = res
            .replace(/[\r\n]+/g, '');
    }
    const oldValue = res;
    res = escape(res, false, options.escapeEntries);
    if (options.classGenerator) {
        res = mangleMark(res, oldValue, options.classGenerator);
    }
    return res;
}

function generateCode(match, options = {}) {
    const ast = parser.parseExpression(match);
    traverse__default["default"](ast, {
        StringLiteral(path) {
            var _a;
            if (path.parent.type === 'BinaryExpression') {
                if (((_a = path.parentPath) === null || _a === void 0 ? void 0 : _a.parent.type) === 'ConditionalExpression') {
                    return;
                }
            }
            path.node.value = replaceWxml(path.node.value, options);
        },
        noScope: true
    });
    const { code } = generate__default["default"](ast, {
        compact: true,
        minified: true,
        jsescOption: {
            quotes: 'single',
            minimal: true
        }
    });
    return code;
}
function extractSource(original) {
    let match = variableMatch(original);
    const sources = [];
    while (match !== null) {
        const start = match.index;
        const end = variableRegExp.lastIndex;
        sources.push({
            start,
            end,
            raw: match[1],
            prevConcatenated: !/\s/.test(original[start - 1]),
            nextConcatenated: !/\s/.test(original[end])
        });
        match = variableMatch(original);
    }
    return sources;
}
function templeteReplacer(original, options = {}) {
    const sources = extractSource(original);
    if (sources.length) {
        const resultArray = [];
        let p = 0;
        for (let i = 0; i < sources.length; i++) {
            const m = sources[i];
            const before = original.slice(p, m.start);
            resultArray.push(replaceWxml(before, {
                keepEOL: true,
                classGenerator: options.classGenerator,
                escapeEntries: options.escapeEntries
            }));
            p = m.start;
            if (m.raw.trim().length) {
                const code = generateCode(m.raw, options);
                let source = `{{${code}}}`;
                if (options.classGenerator) {
                    source = `${m.prevConcatenated ? '' : ' '}${source}${m.nextConcatenated ? '' : ' '}`;
                }
                m.source = source;
            }
            else {
                m.source = '';
            }
            resultArray.push(m.source);
            p = m.end;
            if (i === sources.length - 1) {
                const after = original.slice(m.end);
                resultArray.push(replaceWxml(after, {
                    keepEOL: true,
                    classGenerator: options.classGenerator,
                    escapeEntries: options.escapeEntries
                }));
            }
        }
        return resultArray
            .filter((x) => x)
            .join('')
            .trim();
    }
    else {
        return replaceWxml(original, {
            keepEOL: false,
            classGenerator: options.classGenerator,
            escapeEntries: options.escapeEntries
        });
    }
}
function templeteHandler(rawSource, options = {}) {
    return rawSource.replace(tagWithEitherClassAndHoverClassRegexp, (m0) => {
        return m0.replace(templateClassExactRegexp, (m1, className) => {
            return m1.replace(className, templeteReplacer(className, options));
        });
    });
}
function customTempleteHandler(rawSource, options = {}) {
    let source = templeteHandler(rawSource, options);
    const regexps = makeCustomAttributes(options.customAttributesEntities);
    if (regexps) {
        if (Array.isArray(regexps)) {
            for (let i = 0; i < regexps.length; i++) {
                const regexp = regexps[i];
                source = source.replace(regexp.tagRegexp, (m0) => {
                    return m0.replace(regexp.attrRegexp, (m1, className) => {
                        return m1.replace(className, templeteReplacer(className, options));
                    });
                });
            }
        }
        return source;
    }
    else {
        return source;
    }
}
function createTempleteHandler(options = {}) {
    return (rawSource, opt = {}) => {
        return customTempleteHandler(rawSource, defu(opt, options));
    };
}

const PATTERNS = [/:not\(template\)\s*~\s*:not\(template\)/.source, /:not\(\[hidden\]\)\s*~\s*:not\(\[hidden\]\)/.source].join('|');
const BROAD_MATCH_GLOBAL_REGEXP = new RegExp(PATTERNS, 'g');
function testIfVariablesScope(node) {
    if (/:?:before/.test(node.selector) && /:?:after/.test(node.selector)) {
        const tryTestDecl = node.nodes[0];
        if (tryTestDecl && tryTestDecl.type === 'decl') {
            return tryTestDecl.prop.startsWith('--tw-');
        }
    }
    return false;
}
function commonChunkPreflight(node, options) {
    node.selector = node.selector.replace(BROAD_MATCH_GLOBAL_REGEXP, 'view + view');
    if (testIfVariablesScope(node)) {
        const selectorParts = node.selector.split(',');
        if (!selectorParts.includes('view')) {
            selectorParts.push('view');
        }
        if (options.cssPreflightRange === 'all') {
            if (!selectorParts.includes(':not(not)')) {
                selectorParts.push(':not(not)');
            }
        }
        node.selector = selectorParts.join(',');
        if (typeof options.cssInjectPreflight === 'function') {
            node.append(...options.cssInjectPreflight());
        }
        const pseudoVarRule = new postcss.Rule({
            selector: '::before,::after'
        });
        pseudoVarRule.append(new postcss.Declaration({
            prop: '--tw-content',
            value: '""'
        }));
        node.before(pseudoVarRule);
    }
}

function internalCssSelectorReplacer(selectors, escapeEntries = MappingChars2StringEntries) {
    return escape(selectors, false, escapeEntries);
}

const createTransform = (rule, options) => {
    const replaceFlag = options.replaceUniversalSelectorWith !== false;
    const classGenerator = options.classGenerator;
    const transform = (selectors) => {
        selectors.walk((selector) => {
            if (selector.type === 'universal' && replaceFlag) {
                selector.value = options.replaceUniversalSelectorWith;
            }
            if (selector.type === 'selector') {
                const node = selector.nodes.find((x) => x.type === 'pseudo' && x.value === ':hover');
                node && selector.remove();
            }
            if (selector.type === 'class') {
                selector.value = internalCssSelectorReplacer(selector.value, options.escapeEntries);
                if (classGenerator && selector.value) {
                    let ignore = false;
                    const prev = rule.prev();
                    if ((prev === null || prev === void 0 ? void 0 : prev.type) === 'comment') {
                        ignore = prev.text.includes('mangle') && (prev.text.includes('disabled') || prev.text.includes('ignore'));
                    }
                    if (!ignore) {
                        selector.value = classGenerator.transformCssClass(selector.value);
                    }
                }
            }
        });
        if (selectors.length === 0) {
            rule.remove();
        }
    };
    return transform;
};
const getTransformer = (rule, options) => {
    return selectorParser__default["default"](createTransform(rule, options));
};
const transformSync = (rule, options) => {
    const transformer = getTransformer(rule, options);
    return transformer.transformSync(rule, {
        lossless: false,
        updateSelector: true
    });
};

function styleHandler(rawSource, options) {
    const root = postcss__default["default"].parse(rawSource);
    const { isMainChunk, customRuleCallback } = options;
    const flag = typeof customRuleCallback === 'function';
    root.walk((node) => {
        if (node.type === 'rule') {
            transformSync(node, options);
            if (isMainChunk) {
                commonChunkPreflight(node, options);
            }
            flag && customRuleCallback(node, options);
        }
    });
    return root.toString();
}
function createStyleHandler(options) {
    return (rawSource, opt) => {
        return styleHandler(rawSource, defu(opt, options));
    };
}

function createStartMatchKeyMap(matches) {
    let react = ['className', 'hoverClass', 'hoverClassName', 'class', 'hover-class'];
    let vue2 = ['class', 'staticClass'];
    let vue3 = ['class', 'hover-class'];
    if (matches) {
        react = react.concat(matches);
        vue2 = vue2.concat(matches);
        vue3 = vue3.concat(matches);
    }
    return {
        react,
        vue2,
        vue3
    };
}
function getKey(node) {
    if (node.type === 'Identifier') {
        return node.name;
    }
    if (node.type === 'StringLiteral') {
        return node.value;
    }
    return '';
}
function isObjectKey(type) {
    return ['Identifier', 'StringLiteral'].includes(type);
}
function jsxHandler(rawSource, opt = {
    framework: 'react'
}) {
    var _a;
    const { framework, escapeEntries, allMatchedAttributes } = opt;
    const ast = parser.parse(rawSource, {
        sourceType: 'unambiguous'
    });
    const StartMatchKeyMap = createStartMatchKeyMap(allMatchedAttributes);
    const matchKeys = (_a = StartMatchKeyMap[framework]) !== null && _a !== void 0 ? _a : StartMatchKeyMap.react;
    const isVue2 = framework === 'vue2';
    const isVue3 = framework === 'vue3';
    let startFlag = false;
    const options = {
        ObjectProperty: {
            enter(path) {
                if (isObjectKey(path.node.key.type)) {
                    const keyStr = getKey(path.node.key);
                    if (utils.regExpTest(matchKeys, keyStr)) {
                        startFlag = true;
                    }
                    if (isVue2 && keyStr === 'attrs' && path.node.value.type === 'ObjectExpression') {
                        const idx = path.node.value.properties.findIndex((x) => {
                            return x.type === 'ObjectProperty' && isObjectKey(x.key.type) && getKey(x.key) === 'hover-class';
                        });
                        const hoverClassNode = path.node.value.properties[idx];
                        if (idx > -1 && hoverClassNode.type === 'ObjectProperty') {
                            if (hoverClassNode.value.type === 'StringLiteral') {
                                hoverClassNode.value.value = replaceWxml(hoverClassNode.value.value, {
                                    keepEOL: true,
                                    escapeEntries
                                });
                            }
                        }
                    }
                }
            },
            exit(path) {
                if (['Identifier', 'StringLiteral'].includes(path.node.key.type) && utils.regExpTest(matchKeys, getKey(path.node.key))) {
                    startFlag = false;
                }
            }
        },
        StringLiteral: {
            enter(path) {
                if (startFlag) {
                    path.node.value = replaceWxml(path.node.value, {
                        keepEOL: true,
                        escapeEntries
                    });
                }
            }
        },
        noScope: true
    };
    if (isVue3) {
        options.CallExpression = {
            enter(path) {
                const hit = path.node.arguments[0];
                if (hit && hit.type === 'StringLiteral') {
                    hit.value = templeteHandler(hit.value, {
                        keepEOL: true
                    });
                }
            }
        };
    }
    traverse__default["default"](ast, options);
    return generate__default["default"](ast);
}
function createJsxHandler(options) {
    if (options.customAttributesEntities) {
        const entry = options.customAttributesEntities.find((x) => x[0] === '*');
        if (entry) {
            const t = entry[1];
            if (Array.isArray(t)) {
                options.allMatchedAttributes = t;
            }
            else {
                options.allMatchedAttributes = [t];
            }
        }
    }
    return (rawSource, opt) => {
        return jsxHandler(rawSource, defu(opt, options));
    };
}

const createInjectPreflight = (options) => {
    const result = [];
    if (options && typeof options === 'object') {
        const entries = Object.entries(options);
        for (let i = 0; i < entries.length; i++) {
            const [prop, value] = entries[i];
            if (value !== false) {
                result.push({
                    prop,
                    value: value.toString()
                });
            }
        }
    }
    return () => {
        return result;
    };
};

function getInstalledPkgJsonPath(options) {
    const dangerousOptions = options.dangerousOptions;
    try {
        const tmpJsonPath = require.resolve(`${dangerousOptions.packageName}/package.json`, {
            paths: options.paths
        });
        const pkgJson = require(tmpJsonPath);
        if (semver.gte(pkgJson.version, dangerousOptions.gteVersion)) {
            return tmpJsonPath;
        }
    }
    catch (error) {
        if (error.code === 'MODULE_NOT_FOUND') {
            console.warn('没有找到`tailwindcss`包，请确认是否安装。想要禁用打上rpx支持patch或者非`tailwindcss`框架，你可以设置 `supportCustomLengthUnitsPatch` 为 false');
        }
    }
}
function findAstNode(content, options) {
    const DOPTS = options.dangerousOptions;
    const ast = parser.parse(content);
    let arrayRef;
    let changed = false;
    traverse__default["default"](ast, {
        Identifier(path) {
            var _a;
            if (path.node.name === DOPTS.variableName) {
                if (path.parent.type === 'VariableDeclarator') {
                    if (((_a = path.parent.init) === null || _a === void 0 ? void 0 : _a.type) === 'ArrayExpression') {
                        arrayRef = path.parent.init;
                        const set = new Set(path.parent.init.elements.map((x) => x.value));
                        for (let i = 0; i < options.units.length; i++) {
                            const unit = options.units[i];
                            if (!set.has(unit)) {
                                path.parent.init.elements.push({
                                    type: 'StringLiteral',
                                    value: unit
                                });
                                changed = true;
                            }
                        }
                    }
                }
            }
        }
    });
    return {
        arrayRef,
        changed
    };
}
function internalPatch(pkgJsonPath, options) {
    var _a;
    const { dangerousOptions } = options;
    const DOPTS = dangerousOptions;
    if (pkgJsonPath) {
        const rootDir = path__default["default"].dirname(pkgJsonPath);
        const dataTypesFilePath = path__default["default"].resolve(rootDir, DOPTS.lengthUnitsFilePath);
        const dataTypesFileContent = fs__default["default"].readFileSync(dataTypesFilePath, {
            encoding: 'utf-8'
        });
        const { arrayRef, changed } = findAstNode(dataTypesFileContent, options);
        if (arrayRef && changed) {
            const { code } = generate__default["default"](arrayRef);
            if (arrayRef.start && arrayRef.end) {
                const prev = dataTypesFileContent.slice(0, arrayRef.start);
                const next = dataTypesFileContent.slice(arrayRef.end);
                const newCode = prev + code + next;
                if (DOPTS.overwrite) {
                    fs__default["default"].writeFileSync((_a = DOPTS.destPath) !== null && _a !== void 0 ? _a : dataTypesFilePath, newCode, {
                        encoding: 'utf-8'
                    });
                    console.log('patch tailwindcss for custom length unit successfully!');
                }
                return newCode;
            }
        }
    }
}
function createPatch(options) {
    if (options === false) {
        return utils.noop;
    }
    return () => {
        try {
            return internalPatch(getInstalledPkgJsonPath(options), options);
        }
        catch (error) {
            console.warn(`patch tailwindcss failed:` + error.message);
        }
    };
}

const defaultOptions = {
    cssMatcher: (file) => /.+\.(?:wx|ac|jx|tt|q|c)ss$/.test(file),
    htmlMatcher: (file) => /.+\.(?:(?:(?:wx|ax|jx|ks|tt|q)ml)|swan)$/.test(file),
    jsMatcher: (file) => {
        if (file.includes('node_modules')) {
            return false;
        }
        return /.+\.[jt]sx?$/.test(file);
    },
    mainCssChunkMatcher: (file, appType) => {
        switch (appType) {
            case 'uni-app': {
                return /^common\/main/.test(file);
            }
            case 'mpx': {
                return /^app/.test(file);
            }
            case 'taro': {
                return /^app/.test(file);
            }
            case 'remax': {
                return /^app/.test(file);
            }
            case 'rax': {
                return /^bundle/.test(file);
            }
            case 'native': {
                return /^app/.test(file);
            }
            case 'kbone': {
                return /^(?:common\/)?miniprogram-app/.test(file);
            }
            default: {
                return true;
            }
        }
    },
    cssPreflight: {
        'box-sizing': 'border-box',
        'border-width': '0',
        'border-style': 'solid',
        'border-color': 'currentColor'
    },
    cssPreflightRange: 'view',
    replaceUniversalSelectorWith: 'view',
    disabled: false,
    customRuleCallback: utils.noop,
    onLoad: utils.noop,
    onStart: utils.noop,
    onEnd: utils.noop,
    onUpdate: utils.noop,
    mangle: false,
    framework: 'react',
    loaderOptions: {
        jsxRename: false
    },
    customAttributes: {},
    customReplaceDictionary: MappingChars2String,
    jsxRenameLoaderPath: '',
    supportCustomLengthUnitsPatch: {
        units: ['rpx'],
        dangerousOptions: {
            gteVersion: '3.2.0',
            lengthUnitsFilePath: 'lib/util/dataTypes.js',
            packageName: 'tailwindcss',
            variableName: 'lengthUnits',
            overwrite: true
        }
    }
};
function createGlobMatcher(pattern) {
    return function (file) {
        return micromatch.isMatch(file, pattern);
    };
}
function normalizeMatcher(options, key) {
    if (typeof options[key] === 'string' || Array.isArray(options[key])) {
        options[key] = createGlobMatcher(options[key]);
    }
}
function getOptions(options = {}, modules = ['jsx', 'style', 'templete', 'patch']) {
    const registerModules = modules.reduce((acc, cur) => {
        if (acc[cur] !== undefined) {
            acc[cur] = true;
        }
        return acc;
    }, {
        templete: false,
        jsx: false,
        style: false,
        patch: false
    });
    if (options.mangle === true) {
        options.mangle = {
            exclude: [/node[-_]modules/, /(wx|my|swan|tt|ks|jd)components/]
        };
    }
    else if (typeof options.mangle === 'object') {
        if (!Array.isArray(options.mangle)) {
            options.mangle.exclude = [/node[-_]modules/, /(wx|my|swan|tt|ks|jd)components/];
        }
    }
    if (options.supportCustomLengthUnitsPatch === true) {
        options.supportCustomLengthUnitsPatch = undefined;
    }
    if (options.framework && options.framework === 'vue') {
        options.framework = 'vue2';
    }
    if (options.customReplaceDictionary === 'simple') {
        options.customReplaceDictionary = SimpleMappingChars2String;
    }
    else if (options.customReplaceDictionary === 'complex') {
        options.customReplaceDictionary = undefined;
    }
    normalizeMatcher(options, 'cssMatcher');
    normalizeMatcher(options, 'htmlMatcher');
    normalizeMatcher(options, 'jsMatcher');
    normalizeMatcher(options, 'mainCssChunkMatcher');
    const result = defu(options, defaultOptions);
    const { cssPreflight, customRuleCallback, cssPreflightRange, replaceUniversalSelectorWith, customAttributes, customReplaceDictionary, framework, supportCustomLengthUnitsPatch } = result;
    const cssInjectPreflight = createInjectPreflight(cssPreflight);
    let customAttributesEntities;
    if (utils.isMap(options.customAttributes)) {
        customAttributesEntities = Array.from(options.customAttributes.entries());
    }
    else {
        customAttributesEntities = Object.entries(customAttributes);
    }
    const escapeEntries = Object.entries(customReplaceDictionary);
    result.escapeEntries = escapeEntries;
    if (registerModules.templete) {
        result.templeteHandler = createTempleteHandler({
            customAttributesEntities,
            escapeEntries
        });
    }
    if (registerModules.style) {
        result.styleHandler = createStyleHandler({
            cssInjectPreflight,
            customRuleCallback,
            cssPreflightRange,
            replaceUniversalSelectorWith,
            escapeEntries
        });
    }
    if (registerModules.jsx) {
        result.jsxHandler = createJsxHandler({
            escapeEntries,
            framework,
            customAttributesEntities
        });
    }
    if (registerModules.patch) {
        result.patch = createPatch(supportCustomLengthUnitsPatch);
    }
    return result;
}

exports.commonChunkPreflight = commonChunkPreflight;
exports.createInjectPreflight = createInjectPreflight;
exports.createPatch = createPatch;
exports.getOptions = getOptions;
exports.transformSync = transformSync;
