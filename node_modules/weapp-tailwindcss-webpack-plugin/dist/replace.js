function mangleMark(str, oldValue, classGenerator) {
    if (typeof str === 'string' && str) {
        const oldStrArr = oldValue.split(' ').filter((x) => x);
        return str
            .split(' ')
            .filter((x) => x)
            .map((x, idx) => {
            if (classGenerator.ignoreClassName(x) || classGenerator.ignoreClassName(oldStrArr[idx])) {
                return x;
            }
            return classGenerator.generateClassName(x).name;
        })
            .join(' ');
    }
    return str;
}

const SYMBOL_TABLE = {
    BACKQUOTE: '`',
    TILDE: '~',
    EXCLAM: '!',
    AT: '@',
    NUMBERSIGN: '#',
    DOLLAR: '$',
    PERCENT: '%',
    CARET: '^',
    AMPERSAND: '&',
    ASTERISK: '*',
    PARENLEFT: '(',
    PARENRIGHT: ')',
    MINUS: '-',
    UNDERSCORE: '_',
    EQUAL: '=',
    PLUS: '+',
    BRACKETLEFT: '[',
    BRACELEFT: '{',
    BRACKETRIGHT: ']',
    BRACERIGHT: '}',
    SEMICOLON: ';',
    COLON: ':',
    QUOTE: "'",
    DOUBLEQUOTE: '"',
    BACKSLASH: '\\',
    BAR: '|',
    COMMA: ',',
    LESS: '<',
    PERIOD: '.',
    GREATER: '>',
    SLASH: '/',
    QUESTION: '?',
    SPACE: ' ',
    DOT: '.',
    HASH: '#'
};
const MappingChars2String = {
    '[': '_bl_',
    ']': '_br_',
    '(': '_pl_',
    ')': '_qr_',
    '#': '_h_',
    '!': '_i_',
    '/': '_s_',
    '\\': '_bs_',
    '.': '_d_',
    ':': '_c_',
    '%': '_p_',
    ',': '_co_',
    "'": '_q_',
    '"': '_dq_',
    '*': '_a_',
    '&': '_am_',
    '@': '_at_',
    '{': '_bal_',
    '}': '_bar_',
    '+': '_plus_',
    ';': '_se_',
    '<': '_l_',
    '~': '_t_',
    '=': '_e_',
    '>': '_g_',
    '?': '_qu_',
    '^': '_ca_',
    '`': '_bq_',
    '|': '_b_',
    $: '_do_'
};
const MappingChars2StringEntries = Object.entries(MappingChars2String);
const SimpleMappingChars2String = {
    '[': '_',
    ']': '_',
    '(': '_',
    ')': '_',
    '{': '_',
    '}': '_',
    '+': 'a',
    ',': 'b',
    ':': 'c',
    '.': 'd',
    '=': 'e',
    ';': 'f',
    '>': 'g',
    '#': 'h',
    '!': 'i',
    '@': 'j',
    '^': 'k',
    '<': 'l',
    '*': 'm',
    '&': 'n',
    '?': 'o',
    '%': 'p',
    "'": 'q',
    $: 'r',
    '/': 's',
    '~': 't',
    '|': 'u',
    '`': 'v',
    '\\': 'w',
    '"': 'x'
};
const SimpleMappingChars2StringEntries = Object.entries(SimpleMappingChars2String);

function escapeStringRegexp(str) {
    if (typeof str !== 'string') {
        throw new TypeError('Expected a string');
    }
    return str.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
}

function escape(selectors, raw = false, entries = MappingChars2StringEntries) {
    let res = selectors;
    for (let i = 0; i < entries.length; i++) {
        const [searchValue, replaceValue] = entries[i];
        res = res.replace(new RegExp((raw ? '\\\\' : '') + escapeStringRegexp(searchValue), 'g'), replaceValue);
    }
    return res;
}

function replaceWxml(original, options = {
    keepEOL: false,
    escapeEntries: MappingChars2StringEntries
}) {
    if (typeof options === 'boolean') {
        options = {
            keepEOL: options
        };
    }
    let res = original;
    if (!options.keepEOL) {
        res = res
            .replace(/[\r\n]+/g, '');
    }
    const oldValue = res;
    res = escape(res, false, options.escapeEntries);
    if (options.classGenerator) {
        res = mangleMark(res, oldValue, options.classGenerator);
    }
    return res;
}

function cssSelectorReplacer(selector, escapeEntries = MappingChars2StringEntries) {
    return escape(selector, true, escapeEntries).replace(/\\2c /g, MappingChars2String[',']);
}
function internalCssSelectorReplacer(selectors, escapeEntries = MappingChars2StringEntries) {
    return escape(selectors, false, escapeEntries);
}

export { MappingChars2String, MappingChars2StringEntries, SYMBOL_TABLE, SimpleMappingChars2String, SimpleMappingChars2StringEntries, cssSelectorReplacer as replaceCss, internalCssSelectorReplacer as replaceEscapedCss, replaceWxml as replaceJs };
